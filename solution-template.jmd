---
title: "BEE 4750/5750 Homework 2"
author: "Your name here (your netID here)"
date: `j import Dates; Dates.Date(Dates.now())`
weave_options:
    term: true
    results: tex
    cache: off
---

<!-- This setups the environment and installs packages, but doesn't appear in the generated document -->
<!-- You shouldn't need to modify this -->
```julia; echo = false; results = "hidden"
using Pkg
Pkg.activate(".")
Pkg.instantiate()
```

# Problem 1

## Problem 1.1
```julia
#set all the variables outside the function
B0Riv = 5 #mg/L
N0Riv = 5 #mg/L
B0WS1 = 50 #mg/L
N0WS1 = 35 #mg/L
B0WS2 = 45 #mg/L
N0WS2 = 35 #mg/L 

#create distance vector 
x = 0:1:50

function concentration_calc(x,B0Riv,N0Riv,B0WS1,N0WS1,B0WS2,N0WS2)
    #cut everything here
    #create in function variables
    U = 6 #km/d
    ka = 0.55
    kc = 0.35
    kn = 0.25 
    Cs = 10 #mg/L
    C0Riv = 7.5 #mg/L
    C0WS1 = 5 #mg/L
    C0WS2 = 5 #mg/L
    rivflow = 100000*1000 #L/d 
    ws1flow = 10000*1000 #L/d
    ws2flow = 15000*1000 #L/d
    dist = 15 #km

   

    #calculate concentrations before WS2 
    PreWS2flow = rivflow+ws1flow
    PreWS2C0 = ((C0Riv*rivflow)+(C0WS1*ws1flow))/(PreWS2flow)
    PreWS2B0 = ((B0Riv*rivflow)+(B0WS1*ws1flow))/(PreWS2flow)
    PreWS2N0 = ((N0Riv*rivflow)+(N0WS1*ws1flow))/(PreWS2flow)

    #preallocate a vector for the DO, BOD, NOD
    C = zeros(51,1)
    
    #loop to calculate the concentration before WS2
    for i in 1:(dist+1)
        alpha1 = exp(-(ka*x[i])/U)
        alpha2 = (kc/(ka-kc))*(exp(-(kc*x[i])/U)-exp(-(ka*x[i])/U))
        alpha3 = (kn/(ka-kn))*(exp(-(kn*x[i])/U)-exp(-(ka*x[i])/U))
        global C[i] = (Cs*(1-alpha1))+(PreWS2C0*alpha1)-(PreWS2B0*alpha2)-(PreWS2N0*alpha3)
    end

    #calculate the concentrations after WS2
    PostWS2flow = PreWS2flow + ws2flow
    PostWS2C0 = ((C[dist+1]*PreWS2flow)+(C0WS2*ws2flow))/PostWS2flow
    NewB0 = PreWS2B0*exp(-(kc*(dist+1))/U)
    PostWS2B0 = ((NewB0*PreWS2flow)+(B0WS2*ws2flow))/PostWS2flow
    NewN0 = PreWS2N0*exp(-(kn*(dist+1))/U)
    PostWS2N0 = ((NewN0*PreWS2flow)+(N0WS2*ws2flow))/PostWS2flow
  
    #loop to calculate the concentration after WS2
    for i in (dist+1):51
        newindex = i-(dist)
        alpha1 = exp(-(ka*x[newindex])/U)
        alpha2 = (kc/(ka-kc))*(exp(-(kc*x[newindex])/U)-exp(-(ka*x[newindex])/U))
        alpha3 = (kn/(ka-kn))*(exp(-(kn*x[newindex])/U)-exp(-(ka*x[newindex])/U))
        global C[i] = (Cs*(1-alpha1))+(PostWS2C0*alpha1)-(PostWS2B0*alpha2)-(PostWS2N0*alpha3)
    end   
    return C
end

C = concentration_calc(x,B0Riv,N0Riv,B0WS1,N0WS1,B0WS2,N0WS2)

using Plots
plot(x,C,xlabel="Distance (km)",ylabel="DO Concentration (mg/L)",title="DO vs. distance",label="DO");
vline!([15],label="Waste Source 2");
vline!([0],label="Waste Source 1");
hline!([4],label="Regulatory Limit")
```

## Problem 1.2
```julia
i = 15
distfrom2 = 0
while C[i] < 6
  global distfrom2 = i
  global i = i+1
end
distfrom2 = i
```
The distance from Waste Source 2 until the DO concentration returns to 
6 mg/L is `j distfrom2` km.

## Problem 1.3
```julia
#we want to loop through 0-100 treatment efficiency for the ThOD
#we can plug different B0/N0 into the function from before
Cmin = 0
e = 0
while Cmin < 4 
    local Treat2B0 = ((100-e)/100)*B0WS2
    local Treat2N0 = ((100-e)/100)*N0WS2
    local Ctreated = concentration_calc(x,B0Riv,N0Riv,B0WS1,N0WS1,Treat2B0,Treat2N0)
    global Cmin = minimum(Ctreated)
    global e = e+1
end     
println(e-1)
```
The minimum level of treatment for Waste Source 2 to not go below 4 mg/L is `j (e-1)`. 

## Problem 1.4
```julia
Cmin = 0
e = 0
while Cmin < 4 
    local Treat1B0 = ((100-e)/100)*B0WS1
    local Treat1N0 = ((100-0)/100)*N0WS1
    local Treat2B0 = ((100-e)/100)*B0WS2
    local Treat2N0 = ((100-e)/100)*N0WS2
    local Ctreated = concentration_calc(x,B0Riv,N0Riv,Treat1B0,Treat1N0,Treat2B0,Treat2N0)
    println(Ctreated)
    global Cmin = minimum(Ctreated)
    println(Cmin)
    println(e)
    global e = e+1
end    
```
The minimum level of treatment for both sources to not go below 4 mg/L is `j (e-1)`. 


## Problem 1.5

## Problem 1.6

## Problem 1.7

```julia; echo=false
# This block will not show up in compiled output.

using Distributions
using PDMats

# This function samples n correlated variates distributed over 
# Uniform([a[1], a[2]]) and Uniform([b[1], b[2]]) with correlation coefficient
# corr_coef.
function sample_correlated_uniform(n, a, b, corr_coef=0.7)
  mvnorm = MvNormal([0, 0], PDMat([1 corr_coef; corr_coef 1])) # set up a multivariate normal with each marginal variance of 1 and the right correlation
  norm_samples = rand(mvnorm, n)' # sample from the multivariate normal, the marginal distributions are a standard normal
  unif_samples = cdf.(Normal(0, 1), norm_samples) # convert samples to a uniform distribution using the pdf of a standard Normal
  samples = (unif_samples .* [a[2] - a[1] b[2] - b[1]]) .+ [a[1] b[1]]
  return samples
end
```

## Problem 1.8

```

# References