---
title: "BEE 4750/5750 Homework 2"
author: "Your name here (your netID here)"
date: `j import Dates; Dates.Date(Dates.now())`
weave_options:
    term: true
    results: tex
    cache: off
---

<!-- This setups the environment and installs packages, but doesn't appear in the generated document -->
<!-- You shouldn't need to modify this -->
```julia; echo = false; results = "hidden"
using Pkg
Pkg.activate(".")
Pkg.instantiate()
```

# Problem 1

## Problem 1.1
```julia
#set all the variables outside the function
B0Riv = 5 #mg/L
N0Riv = 5 #mg/L
B0WS1 = 50 #mg/L
N0WS1 = 35 #mg/L
B0WS2 = 45 #mg/L
N0WS2 = 35 #mg/L 

#create distance vector 
x = 0:1:50

function concentration_calc(x,B0Riv,N0Riv,B0WS1,N0WS1,B0WS2,N0WS2)
    #cut everything here
    #create in function variables
    U = 6 #km/d
    ka = 0.55
    kc = 0.35
    kn = 0.25 
    Cs = 10 #mg/L
    C0Riv = 7.5 #mg/L
    C0WS1 = 5 #mg/L
    C0WS2 = 5 #mg/L
    rivflow = 100000*1000 #L/d 
    ws1flow = 10000*1000 #L/d
    ws2flow = 15000*1000 #L/d
    dist = 15 #km

   

    #calculate concentrations before WS2 
    PreWS2flow = rivflow+ws1flow
    PreWS2C0 = ((C0Riv*rivflow)+(C0WS1*ws1flow))/(PreWS2flow)
    PreWS2B0 = ((B0Riv*rivflow)+(B0WS1*ws1flow))/(PreWS2flow)
    PreWS2N0 = ((N0Riv*rivflow)+(N0WS1*ws1flow))/(PreWS2flow)

    #preallocate a vector for the DO, BOD, NOD
    C = zeros(51,1)
    
    #loop to calculate the concentration before WS2
    for i in 1:(dist+1)
        alpha1 = exp(-(ka*x[i])/U)
        alpha2 = (kc/(ka-kc))*(exp(-(kc*x[i])/U)-exp(-(ka*x[i])/U))
        alpha3 = (kn/(ka-kn))*(exp(-(kn*x[i])/U)-exp(-(ka*x[i])/U))
        global C[i] = (Cs*(1-alpha1))+(PreWS2C0*alpha1)-(PreWS2B0*alpha2)-(PreWS2N0*alpha3)
    end

    #calculate the concentrations after WS2
    PostWS2flow = PreWS2flow + ws2flow
    PostWS2C0 = ((C[dist+1]*PreWS2flow)+(C0WS2*ws2flow))/PostWS2flow
    NewB0 = PreWS2B0*exp(-(kc*(dist))/U)
    PostWS2B0 = ((NewB0*PreWS2flow)+(B0WS2*ws2flow))/PostWS2flow
    NewN0 = PreWS2N0*exp(-(kn*(dist))/U)
    PostWS2N0 = ((NewN0*PreWS2flow)+(N0WS2*ws2flow))/PostWS2flow
  
    #loop to calculate the concentration after WS2
    for i in (dist+1):51
        newindex = i-(dist)
        alpha1 = exp(-(ka*x[newindex])/U)
        alpha2 = (kc/(ka-kc))*(exp(-(kc*x[newindex])/U)-exp(-(ka*x[newindex])/U))
        alpha3 = (kn/(ka-kn))*(exp(-(kn*x[newindex])/U)-exp(-(ka*x[newindex])/U))
        global C[i] = (Cs*(1-alpha1))+(PostWS2C0*alpha1)-(PostWS2B0*alpha2)-(PostWS2N0*alpha3)
    end   
    return C
end

C = concentration_calc(x,B0Riv,N0Riv,B0WS1,N0WS1,B0WS2,N0WS2)

using Plots
plot(x,C,xlabel="Distance (km)",ylabel="DO Concentration (mg/L)",title="DO vs. distance",label="DO");
vline!([15],label="Waste Source 2");
vline!([0],label="Waste Source 1");
hline!([4],label="Regulatory Limit")
```

## Problem 1.2
```julia
i = 15
distfrom2 = 0
while C[i] < 6
  global distfrom2 = i
  global i = i+1
end
distfrom2 = i
```
The distance from Waste Source 2 until the DO concentration returns to 
6 mg/L is `j distfrom2` km.

## Problem 1.3
```julia
#we want to loop through 0-100 treatment efficiency for the ThOD
#we can plug different B0/N0 into the function from before
Cmin = 0
e = 0
using Plots
while Cmin < 4 
    local Treat2B0 = ((100-e)/100)*B0WS2
    local Treat2N0 = ((100-e)/100)*N0WS2
    local Ctreated = concentration_calc(x,B0Riv,N0Riv,B0WS1,N0WS1,Treat2B0,Treat2N0)
    global Cmin = minimum(Ctreated)
    global e = e+1
end  
treatws2mineff = e-1
```
The minimum level of treatment for Waste Source 2 to not go below 4 mg/L is `j treatws2mineff`. 

## Problem 1.4
```julia
Cmin = 0
e = 0
while Cmin < 4 
    local Treat1B0 = ((100-e)/100)*B0WS1
    local Treat1N0 = ((100-e)/100)*N0WS1
    local Treat2B0 = ((100-e)/100)*B0WS2
    local Treat2N0 = ((100-e)/100)*N0WS2
    local Ctreated = concentration_calc(x,B0Riv,N0Riv,Treat1B0,Treat1N0,Treat2B0,Treat2N0)
    global Cmin = minimum(Ctreated)
    global e = e+1
end    
treatbothmineff = e-1
```
The minimum level of treatment for both sources to not go below 4 mg/L is `j treatbothmineff`. 


## Problem 1.5
I would opt to treat both waste streams equally to improve conditions in the river between Waste Source 1 and Waste Source 2, even though these improvements are not legally necessary. 
In order to make a more informed decision, it would be helpful to know what the two waste sources are, 
the resources available for treating each source's waste, the specific kind of waste that's producing CBOD and NBOD, 
the ecological conditions of the river, the density of people living at different points in the river, and the communities affected by the river. 
These paameters could influence which source is easier to treat and which parts of the river are more important to conserve. 


## Problem 1.6
```julia
#for 1.6 and 1.7, create new N0 and B0 values given treatment 
Treatby1point5B0WS1 = (1-treatbothmineff)*B0WS1
Treatby1point5N0WS1 = (1-treatbothmineff)*N0WS1
Treatby1point5B0WS2 = (1-treatbothmineff)*B0WS2
Treatby1point5N0WS2 = (1-treatbothmineff)*N0WS2

#create a random sample
totalsamples = 10
#find the minimum C value for each of these new values
NewRivB0 = rand(4:7,totalsamples,1)
NewRivN0 = rand(3:8,totalsamples,1)
function below4(x,RivB0,RivN0,B0WS1,N0WS1,B0WS2,N0WS2)
    global below4count = 0
    for i in eachindex(RivB0)
        for j in eachindex(RivN0)
            C = concentration_calc(x,RivB0[i],RivN0[j],B0WS1,N0WS1,B0WS2,N0WS2)
            if minimum(C)<=4
                global below4count = below4count + 1
            end
        end
    end
    percentbelow4 = round((below4count/(totalsamples*totalsamples))*100)
    return percentbelow4
end

#calculate what percent of Cmin is less than 4 given treatment and variability
percent = below4(x,NewRivB0,NewRivN0,Treatby1point5B0WS1,Treatby1point5N0WS1,Treatby1point5B0WS2,Treatby1point5N0WS2)
```
You will observe DO concentrations below 4 mg/l `j percent`% of the time. 

## Problem 1.7

```julia; echo=false
# This block will not show up in compiled output.

using Distributions
using PDMats

# This function samples n correlated variates distributed over 
# Uniform([a[1], a[2]]) and Uniform([b[1], b[2]]) with correlation coefficient
# corr_coef.
function sample_correlated_uniform(n, a, b, corr_coef=0.7)
  mvnorm = MvNormal([0, 0], PDMat([1 corr_coef; corr_coef 1])) # set up a multivariate normal with each marginal variance of 1 and the right correlation
  norm_samples = rand(mvnorm, n)' # sample from the multivariate normal, the marginal distributions are a standard normal
  unif_samples = cdf.(Normal(0, 1), norm_samples) # convert samples to a uniform distribution using the pdf of a standard Normal
  samples = (unif_samples .* [a[2] - a[1] b[2] - b[1]]) .+ [a[1] b[1]]
  return samples
end
```
```julia


```

## Problem 1.8

```

# References